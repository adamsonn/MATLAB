%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Downloads\treeStructure.dat
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2019/08/14 16:26:28

%% Initialize variables.
filename = 'D:\Downloads\treeStructure.dat';
delimiter = ' ';

%% Format for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
%	column8: double (%f)
%   column9: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string',  'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variablepathnumber
treeStructure = [dataArray{1:end-1}];
%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;



 
%%
0;
treeStructure(1,9)=-1;
IDNumber=treeStructure(:,1);
Parent=treeStructure(:,9);
C = setdiff(IDNumber,Parent);

%   nodes(nodes(1).RightChild.Index).Parent GetRightChild
%   nodes(nodes(1).LeftChild.Index).Parent GetLeftChild

% rawpointsFix = [ xyz0 , xyz1 , diam ] ;
% 
% save rawpointsFix rawpointsFix

%Get all paths back
i=1;
pathnumber=1;
  Pathback(1,pathnumber)=C(i);
while pathnumber<length(C)
    %Endbranch(1)=C(i);
  
    if Pathback(i,pathnumber)==-1
        pathnumber=pathnumber+1;
        Pathback(1,pathnumber)=C(pathnumber);
        
        i=1;
    else
       Pathback(i+1,pathnumber)=Parent(1+Pathback(i,pathnumber));    
       i=i+1;
    end
end

 xyz0 = treeStructure( : , 3:5 ) ;
 
 xyz1 = treeStructure( : , 6:8 ) ;
 
 diam = treeStructure( : ,  2 ) ;
 vector = xyz1 - xyz0;
 i=1;
 while i<length(vector)+1
  Length(i)=norm(vector(i,:));
  i=1+i;
 end
 Length=Length';
 i=1;
 
 %Calcuclates angles from vector
  while i<=length(vector)
  angles(i,1)=acos((vector(i,1))/Length(i));
  angles(i,2)=acos((vector(i,2))/Length(i));
  %horizontal angle
  angles(i,3)=asin((vector(i,3))/Length(i));
  i=1+i;
  end
 
  
% Begin ryan code
import Node;
addpath('.');
nodeArray(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodeArray(i).Diameter = treeStructure(i,2);
    nodeArray(i).Length = Length(i);
    nodeArray(i).alpha = angles(i,1);
    nodeArray(i).beta = angles(i,2);
    nodeArray(i).gamma = angles(i,3);
    nodeArray(i).Parent = treeStructure(i,9);
    nodeArray(i).LeftChild = treeStructure(i);
    nodeArray(i).RightChild = treeStructure(i);
    nodeArray(i).Index = i;
end

nodes(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodes(i).Length = nodeArray(i).Length;
    nodes(i).Diameter = nodeArray(i).Diameter;
    nodes(i).alpha = nodeArray(i).alpha;
    nodes(i).beta = nodeArray(i).beta;
    nodes(i).gamma = nodeArray(i).gamma;
    nodes(i).Resistance = nodeArray(i).Length/nodeArray(i).Diameter;
    nodes(i).Index = i;
    if treeStructure(i,9) >= 0
        nodes(i).Parent = nodeArray(treeStructure(i,9) + 1);
        if isnumeric(nodes(treeStructure(i,9) + 1).LeftChild) == 1
            nodes(treeStructure(i,9) + 1).LeftChild = nodes(i);
        else
            nodes(treeStructure(i,9) + 1).RightChild = nodes(i);
        end
    else
        
    end
end

nodes(1).Parent = nodes(1);

flowMatrix=sscanf(findFlow(300,nodes(1), nodes), '%g,', [2, inf]).';
flowMatrix=sortrows(flowMatrix);
flowMatrix=unique(flowMatrix,'rows');
% end Ryan Code
  
%% Making Flow paths 
%% mimizing propbability

  
  %IDnumber2Prob(6)
  
  
  path1=Pathback(:,1);
  path1=unique(path1);
 
 pathnumber=1;
%Fix first generation having no parent
  Maxflowprop(1)=abs(real(SingleBifucprop(flowMatrix(1,2),nodes(1).Length*10^-2,nodes(1).Diameter*10^-2,nodes(1).gamma,nodes(1).Diameter)));
 %calculates minimum probability
 for i=1:length(nodes)
     Maxflowprop(i)=getProbability(nodes(i),flowMatrix(i,2));
%    =abs(real(SingleBifucprop(flowMatrix(i,2),nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
 %   i=i+1;
 end

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 12;
x0 = zeros(1,mc.NumStates);
x0(1) = 100; % 100 random walks starting from state 1 only
X = simulate(mc,numSteps,'X0',x0);
%  for pathnumber<length(pathback)
%     pathlength=Length(1:length(path1));
%     pathnumber=1+pathnumber;
%  end
% % a=downpath(2);

% for pathnumber=1:length(C)
% while i<=length(C)
% specificpathres(pathnumber,i)=(Length(i)/(diam(i)^4));
% i=i+1;
% end
% i=1;
% pathnumber=pathnumber+1;
% end



% i=1;
% while i<length(LDP)+1
% pathres(i)=(LDP(i,1)/(LDP(i,2)^4));
% i=i+1;
% end
% sum(pathres);
% % 
% %flow in m/s
% i=2;
% maxflow=10*10^-4;
% treeflow=zeros(1,length(LDP));
% treeflow(1)=maxflow;
% while i<length(pathres)+1
%     if mod(i,2)==0
%         mypath=downpath(i);
%         neighborpath=downpath(i+1);
%         treeflow(i)=treeflow(i/2)*(1-sum(pathres(mypath(:)))/(sum(pathres(mypath(:)))+sum(pathres(neighborpath(:)))));
%         i=i+1;
%     else
%         mypath=downpath(i);
%         neighborpath=downpath(i-1);
%         treeflow(i)=treeflow((i-1)/2)*(1-sum(pathres(mypath(:)))/(sum(pathres(mypath(:)))+sum(pathres(neighborpath(:)))));
%         i=i+1;
%     end
% end
% 
% 
% i=1;
% 
% Q=[0.5*10^-5:1*10^-5:10*10^-4];
% while i<length(LDP)+1
%     propline=(real(SingleBifucprop([0.5*10^-5:1*10^-5:10*10^-4],LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),LDP(i,4))));
%     [chance,index]=min(propline);
%     optimalflow(i)=Q(index);
%     i=i+1;
% end
% 
% i=1;
% while i<length(optimalflow)+1
%     if optimalflow(i)>=treeflow(i)
%         optimalflowlim(i)=treeflow(i);
%         else optimalflowlim(i)=optimalflow(i);
%     end
%     i=i+1;
%    
% end
% 
% 
% i=1;
% while i<length(optimalflowlim)+1
%     Qmouth(i)=(optimalflowlim(i)/treeflow(i))*maxflow;
%     i=i+1;
% end
% 
% 
% adjmatrix=zeros(length(LDP)+2,length(LDP)+2);
% i=1;
% while i<length(LDP)+1
%     adjmatrix(i,(length(LDP)+1))=abs(real(SingleBifucprop(treeflow(i),LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),100)));
%     if i<(length(LDP)+1)/2
%         adjmatrix(i,2*i)=abs(real((1-(SingleBifucprop(treeflow(i),LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),100)))/2));
%         adjmatrix(i,2*i+1)=abs(real((1-(SingleBifucprop(treeflow(i),LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),100)))/2));
%     else
%         adjmatrix(i,(length(LDP)+1))=1-abs(real((1-(SingleBifucprop(treeflow(i),LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),100)))));
%         adjmatrix(i,(length(LDP)+2))=abs(real((1-(SingleBifucprop(treeflow(i),LDP(i,1)*10^-3,LDP(i,2)*10^-3,LDP(i,3),100)))));
%     end
%     i=i+1;
%     
% end
% 
% i=1;
% %rng(5)
% %while i<240
%   %  a=randi([32 63],1);
%   %  b=randi([32 63],1);
%   %  adjmatrix(a,b)=adjmatrix(a,65)/2;
%   %  adjmatrix(a,64)=adjmatrix(a,64);
%   %  adjmatrix(a,65)=(adjmatrix(a,65)-adjmatrix(a,65)/2);
%   %  i=i+1;
% %end
% 
% 
% adjmatrix((length(LDP)+1),1)=0;
% adjmatrix((length(LDP)+1),(length(LDP)+1))=1;
% adjmatrix((length(LDP)+2),(length(LDP)+2))=1;
% mc = dtmc(adjmatrix);
% 
% stateNames = ["Deposit" "1" "11" "12" "111" "112" "121" "122" "Escape"];
% %mc.StateNames = stateNames;
% 
% 
% rng(2); % For reproducibility
% % numSteps = 15;
% X0 = zeros(mc.NumStates,1);
% X0(1) = 10000; % 100 random walks starting from state 1 only
% X = simulate(mc,numSteps,'X0',X0);
% 
% 
% 
% 
% %figure;
% %imagesc(mc.adjmatrix);
% %colormap(jet);
% %axis square;
% %colorbar;


