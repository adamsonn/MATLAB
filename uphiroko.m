%% Import data from text file.
% Script for importing data from the following text file:
%
%    D:\Downloads\treeStructure.dat
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2019/08/14 16:26:28

%% Initialize variables.
filename = 'C:\Users\Adam\Documents\MATLAB\treestructure.dat';
delimiter = ' ';

%% Format for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
%	column8: double (%f)
%   column9: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'TextType', 'string',  'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variablepathnumber
treeStructure = [dataArray{1:end-1}];
%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;



 
%%
0;
treeStructure(1,9)=-1;
IDNumber=treeStructure(:,1);
Parent=treeStructure(:,9);
C = setdiff(IDNumber,Parent);

%   nodes(nodes(1).RightChild.Index).Parent GetRightChild
%   nodes(nodes(1).LeftChild.Index).Parent GetLeftChild

% rawpointsFix = [ xyz0 , xyz1 , diam ] ;
% 
% save rawpointsFix rawpointsFix

%Get all paths back
i=1;
pathnumber=1;
  Pathback(1,pathnumber)=C(i);
while pathnumber<length(C)
    %Endbranch(1)=C(i);
  
    if Pathback(i,pathnumber)==-1
        pathnumber=pathnumber+1;
        Pathback(1,pathnumber)=C(pathnumber);
        
        i=1;
    else
       Pathback(i+1,pathnumber)=Parent(1+Pathback(i,pathnumber));    
       i=i+1;
    end
end

 xyz0 = treeStructure( : , 3:5 ) ;
 
 xyz1 = treeStructure( : , 6:8 ) ;
 
 diam = treeStructure( : ,  2 ) ;
 
 %Fix the problem when the lengths are zero
 for i=1:length(xyz1)
    if xyz1(i,:)-xyz0(i,:)==0
       xyz1(i,:)=xyz1(i,:)+.5;
    end
 end
 vector = xyz1 - xyz0;
 i=1;
 while i<length(vector)+1
  Length(i)=norm(vector(i,:));
  i=1+i;
 end
 Length=Length';
 i=1;
 
 %Calcuclates angles from vector
  while i<=length(vector)
  angles(i,1)=acos((vector(i,1))/Length(i));
  angles(i,2)=acos((vector(i,2))/Length(i));
  %horizontal angle
  angles(i,3)=asin((vector(i,3))/Length(i));
  i=1+i;
  end
 
  
% Begin ryan code
import Node;
addpath('.');
nodeArray(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodeArray(i).Diameter = treeStructure(i,2);
    nodeArray(i).Length = Length(i);
    nodeArray(i).alpha = angles(i,1);
    nodeArray(i).beta = angles(i,2);
    nodeArray(i).gamma = angles(i,3);
    nodeArray(i).Parent = treeStructure(i,9);
    nodeArray(i).LeftChild = treeStructure(i);
    nodeArray(i).RightChild = treeStructure(i);
    nodeArray(i).Index = i;
end

nodes(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodes(i).Length = nodeArray(i).Length;
    nodes(i).Diameter = nodeArray(i).Diameter;
    nodes(i).alpha = nodeArray(i).alpha;
    nodes(i).beta = nodeArray(i).beta;
    nodes(i).gamma = nodeArray(i).gamma;
    nodes(i).Resistance = nodeArray(i).Length/nodeArray(i).Diameter;
    nodes(i).Index = i;
    if treeStructure(i,9) >= 0
        nodes(i).Parent = nodeArray(treeStructure(i,9) + 1);
        if isnumeric(nodes(treeStructure(i,9) + 1).LeftChild) == 1
            nodes(treeStructure(i,9) + 1).LeftChild = nodes(i);
        else
            nodes(treeStructure(i,9) + 1).RightChild = nodes(i);
        end
    else
        
    end
end

nodes(1).Parent = nodes(1);

flowMatrix=sscanf(findFlow(1,nodes(1), nodes), '%g,', [2, inf]).';
flowMatrix=sortrows(flowMatrix);
flowMatrix=unique(flowMatrix,'rows');

flowMatrix(:,2)=flowMatrix(:,2)*10^-3; %Sets initial flow
% end Ryan Code
  

 
%% Generate Geomtery
0;
treeStructure(1,9)=-1;
IDNumber=treeStructure(:,1);
Parent=treeStructure(:,9);
C = setdiff(IDNumber,Parent);

%   nodes(nodes(1).RightChild.Index).Parent GetRightChild
%   nodes(nodes(1).LeftChild.Index).Parent GetLeftChild

% rawpointsFix = [ xyz0 , xyz1 , diam ] ;
% 
% save rawpointsFix rawpointsFix

%Get all paths back
i=1;
pathnumber=1;
  Pathback(1,pathnumber)=C(i);
while pathnumber<length(C)
    %Endbranch(1)=C(i);
  
    if Pathback(i,pathnumber)==-1
        pathnumber=pathnumber+1;
        Pathback(1,pathnumber)=C(pathnumber);
        
        i=1;
    else
       Pathback(i+1,pathnumber)=Parent(1+Pathback(i,pathnumber));    
       i=i+1;
    end
end

 xyz0 = treeStructure( : , 3:5 ) ;
 
 xyz1 = treeStructure( : , 6:8 ) ;
 
 diam = treeStructure( : ,  2 ) ;
 
 
 %Fix the problem when the lengths are zero
 for i=1:length(xyz1)
    if xyz1(i,:)-xyz0(i,:)==0
       xyz1(i,:)=xyz1(i,:)+.5;
    end
 end
 vector = xyz1 - xyz0;
 vectoror=vector;
 i=1;
 while i<length(vector)+1
  Length(i)=norm(vector(i,:));
  i=1+i;
 end
 Length=Length';
 i=1;
 
 %Calcuclates angles from vector
  while i<=length(vector)
  angles(i,1)=acos((vector(i,1))/Length(i));
  angles(i,2)=acos((vector(i,2))/Length(i));
  %horizontal angle
  angles(i,3)=asin((vector(i,3))/Length(i));
  i=1+i;
  end
  organgles=angles(:,1);
 
  
% Begin ryan code
import Node;
addpath('.');
nodeArray(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodeArray(i).Diameter = treeStructure(i,2);
    nodeArray(i).Length = Length(i);
    nodeArray(i).alpha = angles(i,1);
    nodeArray(i).beta = angles(i,2);
    nodeArray(i).gamma = angles(i,3);
    nodeArray(i).Parent = treeStructure(i,9);
    nodeArray(i).LeftChild = treeStructure(i);
    nodeArray(i).RightChild = treeStructure(i);
    nodeArray(i).Index = i;
end

nodes(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodes(i).Length = nodeArray(i).Length;
    nodes(i).Diameter = nodeArray(i).Diameter;
    nodes(i).alpha = nodeArray(i).alpha;
    nodes(i).beta = nodeArray(i).beta;
    nodes(i).gamma = nodeArray(i).gamma;
    nodes(i).Resistance = nodeArray(i).Length/nodeArray(i).Diameter;
    nodes(i).Index = i;
    if treeStructure(i,9) >= 0
        nodes(i).Parent = nodeArray(treeStructure(i,9) + 1);
        if isnumeric(nodes(treeStructure(i,9) + 1).LeftChild) == 1
            nodes(treeStructure(i,9) + 1).LeftChild = nodes(i);
        else
            nodes(treeStructure(i,9) + 1).RightChild = nodes(i);
        end
    else
        
    end
end

nodes(1).Parent = nodes(1);

flowMatrix=sscanf(findFlow(1,nodes(1), nodes), '%g,', [2, inf]).';
flowMatrix=sortrows(flowMatrix);
flowMatrix=unique(flowMatrix,'rows');
flowMatrix(:,2)=flowMatrix(:,2)*10^-3;
% end Ryan Code
  
%%  Markov Max Flow

 
  
  
  path1=Pathback(:,1);
  path1=unique(path1);
 
 pathnumber=1;
%Fix first generation having no parent

  Maxflowprop(1)=abs(real(SingleBifucprop(flowMatrix(1,2),nodes(1).Length*10^-2,nodes(1).Diameter*10^-2,nodes(1).gamma,nodes(1).Diameter)));
 %calculates minimum probability
 for i=1:length(nodes)
     Maxflowprop(i)=getProbability(nodes(i),flowMatrix(i,2));
%    =abs(real(SingleBifucprop(flowMatrix(i,2),nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
 %   i=i+1;
 end

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X = simulate(mc,numSteps,'X0',x0);

escapepermax=mean(X(numSteps+1,:)-(length(nodes)+1));


%% Markov half MaxFlow
flowMatrix(:,2)=flowMatrix(:,2)*.5;
  
  %IDnumber2Prob(6)
  
  
  path1=Pathback(:,1);
  path1=unique(path1);
 
 pathnumber=1;
%Fix first generation having no parent
flowMatrix(:,2)=flowMatrix(:,2); %Sets initial flow
  Maxflowprop(1)=abs(real(SingleBifucprop(flowMatrix(1,2),nodes(1).Length*10^-2,nodes(1).Diameter*10^-2,nodes(1).gamma,nodes(1).Diameter)));
 %calculates minimum probability
 for i=1:length(nodes)
     Maxflowprop(i)=getProbability(nodes(i),flowMatrix(i,2));
%    =abs(real(SingleBifucprop(flowMatrix(i,2),nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
 %   i=i+1;
 end

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X1 = simulate(mc,numSteps,'X0',x0);
%Esxape percent from lasr row
escapepermaxhalf=mean(X1(numSteps+1,:)-(length(nodes)+1));
%Bring flow back up
flowMatrix(:,2)=flowMatrix(:,2)*2;



%% Redo simulations for Minimizing flow
i=1;

for i=i:length(nodes)
    flowsearch=[10^-10:1*10^-8:flowMatrix(i,2)];
    probline=(real(SingleBifucprop([10^-10:1*10^-8:flowMatrix(i,2)],nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
    if flowMatrix(i,2)==0
        optiflow(i)=1;%fixes problem with zero flow members
    elseif probline(length(probline))==max(probline)
            optiflow(i)=1;
    else
            [minprop(i),y]=min(probline);
            optiflow(i)=flowsearch(y)/(flowMatrix(i,2));%percent ofmax
            i=i+1;
    end
end
plot(optiflow)

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X2 = simulate(mc,numSteps,'X0',x0);

escapeperopt=mean(X2(numSteps+1,:)-(length(nodes)+1));

%% Generate Geomtery rotated
0;
treeStructure(1,9)=-1;
IDNumber=treeStructure(:,1);
Parent=treeStructure(:,9);
C = setdiff(IDNumber,Parent);

%   nodes(nodes(1).RightChild.Index).Parent GetRightChild
%   nodes(nodes(1).LeftChild.Index).Parent GetLeftChild

% rawpointsFix = [ xyz0 , xyz1 , diam ] ;
% 
% save rawpointsFix rawpointsFix

%Get all paths back
i=1;
pathnumber=1;
  Pathback(1,pathnumber)=C(i);
while pathnumber<length(C)
    %Endbranch(1)=C(i);
  
    if Pathback(i,pathnumber)==-1
        pathnumber=pathnumber+1;
        Pathback(1,pathnumber)=C(pathnumber);
        
        i=1;
    else
       Pathback(i+1,pathnumber)=Parent(1+Pathback(i,pathnumber));    
       i=i+1;
    end
end

 xyz0 = treeStructure( : , 3:5 ) ;
 
 xyz1 = treeStructure( : , 6:8 ) ;
 
%  while i<length(xyz0)+1
% 
% xyz0(i,1:3)=xyz0(i,1:3)*rotmat([0,pi/2,pi/2]);
% xyz1(i,1:3)=xyz1(i,1:3)*rotmat([0,pi/2,pi/2]);
% end



 diam = treeStructure( : ,  2 ) ;
 
 %Fix the problem when the lengths are zero
 for i=1:length(xyz1)
    if xyz1(i,:)-xyz0(i,:)==0
       xyz1(i,:)=xyz1(i,:)+.5;
    end
 end
 vector = xyz1 - xyz0;
 i=1;
 
 vector =rotmat([pi/4,pi/3,0])*vector';
  vector =vector';
 while i<length(vector)+1
  Length(i)=norm(vector(i,:));
  i=1+i;
 end
 Length=Length';
 i=1;
 
 %Calcuclates angles from vector
  while i<=length(vector)
  angles(i,1)=acos((vector(i,1))/Length(i));
  angles(i,2)=acos((vector(i,2))/Length(i));
  %horizontal angle
  angles(i,3)=asin((vector(i,3))/Length(i));
  i=1+i;
  end
 
 rotangles=angles(:,1); 
% Begin ryan code
import Node;
addpath('.');
nodeArray(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodeArray(i).Diameter = treeStructure(i,2);
    nodeArray(i).Length = Length(i);
    nodeArray(i).alpha = angles(i,1);
    nodeArray(i).beta = angles(i,2);
    nodeArray(i).gamma = angles(i,3);
    nodeArray(i).Parent = treeStructure(i,9);
    nodeArray(i).LeftChild = treeStructure(i);
    nodeArray(i).RightChild = treeStructure(i);
    nodeArray(i).Index = i;
end

nodes(1:1,1:length(treeStructure)) = Node(1,1,1,1,1,1,1,1,1);
for i=1:length(treeStructure)
    nodes(i).Length = nodeArray(i).Length;
    nodes(i).Diameter = nodeArray(i).Diameter;
    nodes(i).alpha = nodeArray(i).alpha;
    nodes(i).beta = nodeArray(i).beta;
    nodes(i).gamma = nodeArray(i).gamma;
    nodes(i).Resistance = nodeArray(i).Length/nodeArray(i).Diameter;
    nodes(i).Index = i;
    if treeStructure(i,9) >= 0
        nodes(i).Parent = nodeArray(treeStructure(i,9) + 1);
        if isnumeric(nodes(treeStructure(i,9) + 1).LeftChild) == 1
            nodes(treeStructure(i,9) + 1).LeftChild = nodes(i);
        else
            nodes(treeStructure(i,9) + 1).RightChild = nodes(i);
        end
    else
        
    end
end

nodes(1).Parent = nodes(1);

flowMatrix=sscanf(findFlow(1,nodes(1), nodes), '%g,', [2, inf]).';
flowMatrix=sortrows(flowMatrix);
flowMatrix=unique(flowMatrix,'rows');

flowMatrix(:,2)=flowMatrix(:,2)*10^-3;
% end Ryan Code
  

%% Redo simulations for titled max flow
  %IDnumber2Prob(6)
  
  
  path1=Pathback(:,1);
  path1=unique(path1);
 
 pathnumber=1;
%Fix first generation having no parent
flowMatrix(:,2)=flowMatrix(:,2); %Sets initial flow
  Maxflowprop(1)=abs(real(SingleBifucprop(flowMatrix(1,2),nodes(1).Length*10^-2,nodes(1).Diameter*10^-2,nodes(1).gamma,nodes(1).Diameter)));
 %calculates minimum probability
 for i=1:length(nodes)
     Maxflowprop(i)=getProbability(nodes(i),flowMatrix(i,2));
%    =abs(real(SingleBifucprop(flowMatrix(i,2),nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
 %   i=i+1;
 end

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);


rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X2 = simulate(mc,numSteps,'X0',x0);

escapepermaxrot=mean(X2(numSteps+1,:)-(length(nodes)+1));

%% %% Redo simulations for Minimizing flow titled
i=1;

for i=i:length(nodes)
    flowsearch=[10^-10:1*10^-8:flowMatrix(i,2)];
    probline=(real(SingleBifucprop([10^-10:1*10^-8:flowMatrix(i,2)],nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
    if flowMatrix(i,2)==0
        optiflow(i)=1;%fixes problem with zero flow members
    elseif probline(length(probline))==max(probline)
            optiflow(i)=1;
    else
            [minprop(i),y]=min(probline);
            optiflow(i)=flowsearch(y)/(flowMatrix(i,2));%percent ofmax
            i=i+1;
    end
end
plot(optiflow)

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)*optiflow(i)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X4 = simulate(mc,numSteps,'X0',x0);

escapeperoptrot=mean(X4(numSteps+1,:)-(length(nodes)+1));

%% Markov half MaxFlow
flowMatrix(:,2)=flowMatrix(:,2)*.5;
  
  %IDnumber2Prob(6)
  
  
  path1=Pathback(:,1);
  path1=unique(path1);
 
 pathnumber=1;
%Fix first generation having no parent
flowMatrix(:,2)=flowMatrix(:,2); %Sets initial flow
  Maxflowprop(1)=abs(real(SingleBifucprop(flowMatrix(1,2),nodes(1).Length*10^-2,nodes(1).Diameter*10^-2,nodes(1).gamma,nodes(1).Diameter)));
 %calculates minimum probability
 for i=1:length(nodes)
     Maxflowprop(i)=getProbability(nodes(i),flowMatrix(i,2));
%    =abs(real(SingleBifucprop(flowMatrix(i,2),nodes(i).Length*10^-2,nodes(i).Diameter*10^-2,nodes(i).gamma,nodes(i).Parent.Diameter)));
 %   i=i+1;
 end

adjmatrix=zeros(length(nodes)+2,length(nodes)+2);

 for i=1:length(nodes)
     left=nodes(i).LeftChild;
     right=nodes(i).RightChild;
     if isnumeric(left) == 0
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,left.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(left.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(right) == 0
         adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
         adjmatrix(i,right.Index)=(1-getProbability(nodes(i),flowMatrix(i,2)))*(flowMatrix(right.Index,2)/(flowMatrix(left.Index,2)+flowMatrix(right.Index,2)));
     end
     if isnumeric(left) && isnumeric(right) % Leaf
        adjmatrix(i,length(nodes)+1)=getProbability(nodes(i),flowMatrix(i,2)); %chance of capture
        adjmatrix(i,length(nodes)+2)=1 - getProbability(nodes(i),flowMatrix(i,2)); %chance of escape
     end
 end
 
adjmatrix(length(nodes)+1,length(nodes)+1)=1;
adjmatrix(length(nodes)+2,length(nodes)+2)=1;

mc = dtmc(adjmatrix);

rng(2); % For reproducibility
numSteps = 15;
x0 = zeros(1,mc.NumStates);
x0(1) = 1000; % 100 random walks starting from state 1 only
X1 = simulate(mc,numSteps,'X0',x0);
%Esxape percent from lasr row
escapepermaxhalfrot=mean(X1(numSteps+1,:)-(length(nodes)+1));
%Bring flow back up
flowMatrix(:,2)=flowMatrix(:,2)*2;


%% 
